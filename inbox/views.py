from django.shortcuts import render
from django.contrib import messages
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.decorators import user_passes_test
from .models import Message
from main.models import Report
from users.models import Profile
import imghdr
import datetime

import random
from django.core.files.storage import default_storage
from django.contrib.auth.decorators import user_passes_test
from django.contrib import messages
from django.core.exceptions import PermissionDenied


import string
from random import SystemRandom
import os


# CONSTs
# Each of these consts are loaded from environment variables
# The maximum number of images associated with a single report (integer)
maximum_image_count = int(os.getenv('MAX_MESSAGE_IMAGES', default=25))
# The maximum size in bytes of an image attached in a message (integer)
maximum_image_size = int(os.getenv('MAX_MESSAGE_IMAGE_SIZE', default=5242880))
# The file types allowed for image upload (list generated by string, see default for format)
valid_image_types = os.getenv('VALID_MESSAGE_IMAGE_TYPES', default='jpeg, jpg, png')
valid_image_types = [img_type.strip() for img_type in valid_image_types.split(',')]
# Whether or not to tag new messages with the 'new' tag when the viewing user is not the last person to generate
#   a message on a report. Either 1 or 0, cast to a bool, default is to tag messages (1)
tag_new_messages = bool(os.getenv('TAG_NEW_MESSAGES', default=1))



# This function consumes a list of message objects and returns a 'conversation' a list of message
# dictionaries ordered by timestamp

def legal_check(user):
    if user.legal.terms_accepted:
        return True
    raise PermissionDenied

def make_conversation(messages):
    conversation = []
    for message in messages:
        conversation.append(make_message(message))

    conversation = sorted(conversation, key=lambda m: m['timestamp'])

    return conversation

# This function consumes a message object returned from the database and returns a dictionary with keys for each
#   field of the message object. This format is suitable for consumption by the templating code on the front end
def make_message(message):
    return {'id':message.id,
            'sender':message.sender,
            'body':message.message_text,
            'image':message.message_image,
            'timestamp':message.message_timestamp}

# This function takes a report object and a user object and determines if, for that user, there are new messages on
#   the passed report. A report is said to have new messages for a user if a different user was the last person to
#   create a message attached to that report.
def are_messages_new(report, user):

    # Check if messages should be tagged as new or left untagged
    if not(tag_new_messages):
        return False

    report_messages = list(Message.objects.filter(report=report))

    # In this case there are no messages attached to the report
    if report_messages == []:
        return False

    # The last sender is the last user (student or admin) to attach a message to a report
    last_sender = report_messages[-1].sender

    # If the user passed to this function is not the last user, then the user has new or unanswered messages on
    #   this report.
    if last_sender != user:
        return True
    else:
        return False

# This function constructs the report list displayed to a user when they open their inbox page
#   The function is passed a list of report objects and returns a list of dictionaries whose keys are the
#   relevant fields of the report (Id, title, status of messages [new, not-new].
# Note: one can disable the 'new message' functionality by setting the env variable 'TAG_NEW_MESSAGES'
def make_report_list(user_reports, user):
    report_list = []
    for report in user_reports:
        report_list.append({'id':report.id, 'title':report.title, 'new':are_messages_new(report, user)})

    return report_list

# The function checks that a report number exists within a user's list of reports
#   The function is passed a user's report list (a list containing dictionaries built from report objects) and a
#   report id number, and returns true if the requested report number exists in a user's report list
#   This function is used to ensure that a user requesting messages for a particular report is either the user
#   who created the report or an admin. Note that all reports will appear in an admin's user report list.
def report_number_is_valid(user_report_list, report_number):
    id_list = []
    for report in user_report_list:
        id_list.append(report['id'])

    if report_number in id_list:
        return True
    return False

# This is a check function that returns true if a report has less than the maximum image count or false if the report
#   has more than the maximum number of images.
#   This function is used to ensure that a single report never contains more images than the maximum and is invoked when
#   creating a new message that includes an image.
def report_under_image_maximum(report):
    report_messages = Message.objects.filter(report=report)  # Get all messages on a report

    # compute a list of image names from the list of messages for a report
    # Note that messages that do not contain images will have an message_image.name of '', so we filter these out
    images = [message.message_image for message in report_messages if message.message_image.name != '']

    # Check if the number of images is less than the maximum
    if len(images) < maximum_image_count:
        return True
    else:
        return False

# Wrapper function to call each validity check function and additional tests on a particular image which the user is
# attempting to include in a message for a particular report.
# This functions verifies that:
#                               1. The image format is valid (based on headers, see imghdr.what)
#                               2. The image size is under the maximum
#                               3. The report has less than the maximum number of images in attached messages
def image_is_valid(image, report):
    if imghdr.what(image) in valid_image_types and image.size < maximum_image_size and report_under_image_maximum(report):
        return True
    return False


# This function consumes a report number and a user and returns a filename suitable for an image attached to a report
#   message. File names are of the format year-month-day-hour-minute-second-entropy-userid-reportid
#   Where entropy is used to ensure that filenames are not easily guessable and is generated using python random.
def generate_filename(report_number, user):
    # UTC datetime timestamp
    time = datetime.datetime.utcnow()
    time = str(time).replace(',','-').replace(' ', '-').replace('.','-').replace(':', '-')

    # Entropy to make the guessing of uploaded file names more difficult
    # Generates 16 digits of random ascii letters and digits
    entropy_chars=string.ascii_letters + string.digits
    entropy = ''.join(SystemRandom().choice(entropy_chars) for i in range(16))

    filename = time + '-' + str(user.id) + '-' + str(entropy) + '-' + str(report_number)
    return filename

# Saving function for new messages to be attached to a report. This function consumes a request object (passed from a
#   post) and a report number (report id) and saves all of its fields as a new message object attached to the report
#   if the message passes validity checks.
def save_message(request, report_number):

    # Load the message text, user sending the message, report to attach the message to
    message_text = request.POST['message_text']
    sender = request.user
    report = Report.objects.filter(id=report_number)[0]
    message_image = None

    # If an image was included in the post, validate it, generate a filename and allow it be included in the message
    # If an image is invalid, return False for this function (This cancels the message saving)
    if 'message_image' in request.FILES:
        image = request.FILES['message_image']
        if image_is_valid(image, report):
            message_image = image
            message_image.name = generate_filename(report_number, sender)
        else:
            return False

    # Save the new message, with or without an image depending on what content was passed to the function
    if message_image is not None:
        new_message = Message(sender=sender, report=report, message_text=message_text, message_image=message_image)
    else:
        new_message = Message(sender=sender, report=report, message_text=message_text)

    new_message.save()
    return True  # True is returned if a message save was successful

# Main inbox view function, consumes a request and an option report number. This function handles both GETs and POSTs
#   and also handles views for both normal users and admin users. reportnumber is only passed if a user is looking at
#   a particular report on the inbox page (i.e., they have it 'focused'), otherwise reportnumber is None.

@login_required
@user_passes_test(legal_check)
def inbox(request, reportnumber=None):
    message_status = True

    # Handle the case where a POST is made, and a report number is given
    # Save the new message to the passed report number (validation takes place in the called functions)
    # Also checks to ensure that a message
    # Message status is set to the return value of the save function. If a message cannot be posted (e.g., it is invalid
    #   then false will be returned.
    if request.method == "POST" and reportnumber is not None and\
            (request.POST['message_text']!='' or 'message_image' in request.FILES):
        message_status = save_message(request, reportnumber)

    # Check if the user is a staff member (admin)
    user_is_staff = request.user.is_staff

    # Assign the user their associated list of reports based on their permission level. Users are permitted to see
    #   only their own reports while admins can see all reports generated by any user.
    # Note that this is the code which handles validation for a user's access to reports, the later functions called
    #   will not double check that a user is permitted to view a report
    if user_is_staff:
        all_reports = Report.objects.all()
        report_list = make_report_list(all_reports, request.user)
    else:
        #  Reports are not linked to users but instead to their profile so we need to resolve the
        #    profile first and then load reports from there.
        # We first load a user profile object and then read a list of their reports from the database which is then
        #   passed to the make_report_list function to format it for front-end use
        user_profile = Profile.objects.filter(user=request.user)[0]
        user_reports = Report.objects.filter(author=user_profile)
        report_list = make_report_list(user_reports, request.user)

    # This section chooses to 'focus' a particular report and show its details and messages.
    # This section also populates the report list which will be displayed on the side bar.
    # If the user has no reports, ie their report list is empty, simply render the page without a focus
    if len(report_list) == 0:
        return render(request, 'inbox/inbox_home.html')

    # if the user provided a report number and the number is valid, focus this report
    elif reportnumber is not None and (report_number_is_valid(report_list, reportnumber) or user_is_staff):
        focused_report_number = reportnumber

    # if the user did not provide a report number or their report number was invalid, render the page without a focus
    #   This is the default response to a GET on the inbox page, before a user has selected a report. Unlike the case
    #   where a user does not have any reports, we do return a report list in this case, which will populate the side
    #   bar and allow the user to select a report to focus
    else:
        return render(request, 'inbox/inbox_home.html', {'report_list':report_list})

    #  If a valid focused report is given, prepare its message contents for the front end
    # If a user is a staff member (admin) all they are permitted to view messages for all reports
    if user_is_staff:
        focused_report = Report.objects.filter(id=focused_report_number)[0]
    else:
        focused_report = Report.objects.filter(id=focused_report_number, author=user_profile)[0]

    # Get messages for the focused report
    focused_report_messages = Message.objects.filter(report=focused_report)

    # Format the messages into a 'conversation' for display on the front end
    conversation = make_conversation(focused_report_messages)

    # Return the report list (for the side bar), the conversation of the focused report, the report number (focused
    #   report), the status of the report, and the message_status (If a new message was added successfully
    # Note the we return the not of the message status, so it will be True if saving a new message failed and False
    # if the message save was successful. This is so the variable can be used by the template like 'if message status'

    return render(request, 'inbox/inbox_home.html', {'report_list':report_list,
                                                     'conversation':conversation,
                                                     'report':focused_report,
                                                     'report_status':str(focused_report.status).replace('_', ' '),
                                                     'message_status':not(message_status)})